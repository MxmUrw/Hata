
module Verification.Core.Computation.Unification.Categorical2.ZeroIdeal where

open import Verification.Conventions
open import Verification.Core.Set.Setoid
open import Verification.Core.Order.Preorder
open import Verification.Core.Order.Lattice
open import Verification.Core.Order.WellFounded.Definition
open import Verification.Core.Data.Universe.Definition
open import Verification.Core.Data.Universe.Instance.Category
open import Verification.Core.Category.Std.Category.Definition
open import Verification.Core.Category.Std.Category.Sized.Definition
open import Verification.Core.Category.Std.Morphism.Epi.Definition
open import Verification.Core.Category.Std.Category.As.ZeroMorphismCategory.Definition
open import Verification.Core.Computation.Unification.Categorical2.Ideal


-- ===* The zero ideal
-- | Remember that the ideals we are interested in
--   are formed as "set of arrows which unify |t| and |s|",
--   for two terms |t| and |s|. Now if these terms
--   do not have a unifier in |ğ’ğ®ğ›ğ¬ğ­-FO|, then
--   they still have a unifier in |Free-ğ™ğŒğ‚ğšğ­ ğ’ğ®ğ›ğ¬ğ­-FO|,
--   namely |0| itself.
--   Expressed more formally, we know that |(t â—† pt) âˆ¼ pt âˆ¼ (s â—† pt)| always holds.

-- [Definition]
-- | The ideal containing only |pt| is called the /zero ideal/
--   and is denoted by |âŠ¥-Ideal|.

-- //

-- | This means that if |t| and |s| do not have a unifier,
--   the ideal generated by them is the zero ideal. We
--   can also show the following property of |âŠ¥-Ideal|.

-- [Lemma]
-- | The ideal |âŠ¥-Ideal| is a bottom element of the
--   preorder of ideals at any object |a| of |ğ’|.

-- //

-- [Proof]
-- | To show this, we merely must show that there is
--   a subset inclusion of |âŠ¥-Ideal| into any other
--   ideal. But the |âŠ¥-Ideal| only contains |pt|,
--   and by definition (evidenced by the
--   record field |ideal-pt|) every ideal contains |pt|.

-- //


-- [Hide]
module _ {ğ’ : ğ’° ğ‘–}
         {{_ : isCategory {ğ‘—} ğ’}}
         {{_ : isZeroMorphismCategory â€² ğ’ â€²}}
         where
  -- private
  --   ğ’ = âŸ¨ ğ’' âŸ©

-- module _ {ğ‘–} {ğ’ : ğ’° _} {{_ : ğ™ğŒğ‚ğšğ­ ğ‘– on ğ’}} where
  module _ {a : ğ’} where
    record âŠ¥-Idealáµ˜ {b : ğ’} (f : a âŸ¶ b) : ğ’° (ğ‘– ï½¤ ğ‘—) where
      constructor incl
      field âŸ¨_âŸ© : f âˆ¼ pt

    open âŠ¥-Idealáµ˜ public

    macro
      âŠ¥-Ideal = #structureOn (Î» {b} -> âŠ¥-Idealáµ˜ {b})


    instance
      isIdeal:âŠ¥-Ideal : isIdeal a âŠ¥-Idealáµ˜
      isIdeal:âŠ¥-Ideal = record
        { transp-Ideal = Î» fâˆ¼g (incl fâˆ¼pt) â†’ incl (fâˆ¼g â»Â¹ âˆ™ fâˆ¼pt)
        ; ideal-r-â—†     = Î» (incl fâˆ¼pt) g â†’ incl ((fâˆ¼pt â—ˆ refl) âˆ™ absorb-l-â—†)
        ; ideal-pt      = incl refl
        }

    initial-âŠ¥-Ideal : âˆ€{I : Ideal a} -> â€² (Î» {b} -> âŠ¥-Idealáµ˜ {b}) â€² â‰¤ I
    initial-âŠ¥-Ideal = incl Î» f (incl fâˆ¼pt) â†’ transp-Ideal (fâˆ¼pt â»Â¹) ideal-pt

-- //

