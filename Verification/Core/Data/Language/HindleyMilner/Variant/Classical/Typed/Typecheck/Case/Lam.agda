
module Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Typecheck.Case.Lam where

open import Verification.Conventions hiding (â„• ; _âŠ”_)

open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Imports

open import Verification.Core.Data.Language.HindleyMilner.Type.Variant.FreeFiniteCoproductTheoryTerm.Definition
open import Verification.Core.Data.Language.HindleyMilner.Type.Variant.FreeFiniteCoproductTheoryTerm.Signature
open import Verification.Core.Data.Language.HindleyMilner.Helpers
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Untyped.Definition
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Context
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Context.Definition
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Context.Properties
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Definition
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Typecheck.Statement
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Definition2




-- [Lemma]
-- | "Inversion of Lam"

inv-lam : âˆ€{k Î¼s} {Q : â„’HMQuant k} {Î“ : â„’HMCtx Q Î¼s} {Ï„ : â„’HMType âŸ¨ Î¼s âŸ©}
           --------------------------------------
           -- constructor inputs
           -> {te : Untypedâ„’HM (tt âˆ· k)}
           --------------------------------------
           -- condition: is typed
           -> isTypedâ„’HM (Î¼s âŠ© Î“ âŠ¢ Ï„) (lam te)
           --------------------------------------
           -- result: we have a lot
           -> âˆ‘ Î» (Î± : â„’HMType âŸ¨ Î¼s âŠ” âŠ¥ âŸ©)
           -> âˆ‘ Î» (Î² : â„’HMType âŸ¨ Î¼s âŸ©)
           -> (Î± â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ â‡’ Î² â‰¡ Ï„)
              Ã—-ğ’° isTypedâ„’HM (Î¼s âŠ© Î± âˆ· Î“ âŠ¢ Î²) te
inv-lam = {!!}

-- //


-- [Proposition]
-- | Assuming the induction hypothesis, the /lam/ case is
--   typecheckable with an initial typing instance.

-- //


-- [Proof]
-- | Let [..], [..], [..], [..] be the input of the
--   algorithm.
module typecheck-lam {Î¼s : â„’HMTypes} {k : â™®â„•} {Q : â„’HMQuant k} (Î“ : â„’HMCtx Q Î¼s) where

  -- | Furthermore, assume we have the term [..].
  module _ (te : Untypedâ„’HM (tt âˆ· k)) where

    -- | First we create a context with a new metavariable.

    Î¼sâ‚€ = Î¼s âŠ” st

    Î±áµ˜ : â„’HMType âŸ¨ st âŸ©
    Î±áµ˜ = var incl

    Î±â‚€ : â„’HMType âŸ¨ Î¼sâ‚€ âŠ” âŠ¥ âŸ©
    Î±â‚€ = Î±áµ˜ â‡ƒ[ Î¹â‚ â—† Î¹â‚€ ]â‡‚

    -- create the context which contains this new variable
    Î“â‚€ : â„’HMCtx Q Î¼sâ‚€
    Î“â‚€ = Î“ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ

    Ïƒâ‚€ : Î¼s âŸ¶ Î¼s âŠ” st
    Ïƒâ‚€ = Î¹â‚€

    Î“<Î“â‚€ : Î“ <Î“ Î“â‚€
    Î“<Î“â‚€ = record { fst = Î¹â‚€ ; snd = refl-â‰¡ }

    -- call typechecking recursively on `te`
    -- res = Î³ (Î±â‚€ âˆ· Î“â‚€) te

    -- | Next, the algorithm computes the typing for |te|,
    --   thus we assume that there is such a typing instance.
    module _ (ğ‘‡-te! : InitialCtxTypingInstance (Î±â‚€ âˆ· Î“â‚€) te) where

      open Î£ ğ‘‡-te! renaming
        ( fst to ğ‘‡-te
        ; snd to Î©
        )

      open CtxTypingInstance ğ‘‡-te renaming
        ( metas to Î¼sâ‚â‚
        ; typeMetas to Î¼sâ‚â‚“
        ; ctx to Î”
        ; typ to Î²â‚
        ; isInstance to Î±â‚€Î“â‚€<Î±â‚Î“â‚
        ; hasType to Î”âŠ¢Î²â‚
        )
      -- (Î¼sâ‚â‚ / Î¼sâ‚â‚“ âŠ© (Î±â‚ âˆ· Î“â‚) , Î²â‚ , Î±â‚€Î“â‚€<Î±â‚Î“â‚ , Î±â‚Î“â‚âŠ¢Î²â‚)

      -----------------------------------------
      -- Restoration of |Î±â‚Î“â‚ â‰¡ Î”|

      -- | Now, we restore |Î±â‚Î“â‚ â‰¡ Î”|.
      Î±â‚ = split-Listá´°Â² Î” .fst
      Î“â‚ = split-Listá´°Â² Î” .snd

      -- | Call this one
      Î±â‚Î“â‚ : â„’HMCtx (âŠ¥ âˆ·' Q) Î¼sâ‚â‚
      Î±â‚Î“â‚ = Î±â‚ âˆ· Î“â‚

      -- | And we have actually [..] [] [].
      lem-00 : Î” â‰¡ Î±â‚Î“â‚
      lem-00 = {!!}

      Î±â‚Î“â‚âŠ¢Î²â‚ : isTypedâ„’HM ((Î¼sâ‚â‚ âŠ” Î¼sâ‚â‚“) âŠ© Î±â‚Î“â‚ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ âŠ¢ Î²â‚) te
      Î±â‚Î“â‚âŠ¢Î²â‚ = Î”âŠ¢Î²â‚
                  âŸª transp-isTypedâ„’HM (cong (_â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ) lem-00) refl-â‰¡ âŸ«

      -----------------------------------------
      -- actual proof

      -- | The following definitions follow.
      Ïƒáµƒâ‚€â‚ : Î¼sâ‚€ âŸ¶ Î¼sâ‚â‚
      Ïƒáµƒâ‚€â‚ = Î±â‚€Î“â‚€<Î±â‚Î“â‚ .fst

      Î“â‚€<Î“â‚ : Î“â‚€ <Î“ Î“â‚
      Î“â‚€<Î“â‚ = record { fst = Ïƒáµƒâ‚€â‚ ; snd = {!!} }
        -- tail-Someâ„’HMCtx (Î±â‚€Î“â‚€<Î±â‚Î“â‚)

      f : Î¼s âŸ¶ Î¼sâ‚â‚
      f = Î¹â‚€ â—† Ïƒáµƒâ‚€â‚

      factor:f = factorize f

      Î¼sâ‚‚â‚ = image factor:f
      Î¼sâ‚‚â‚“ = rest factor:f
      Î¼sâ‚‚ = Î¼sâ‚‚â‚ âŠ” Î¼sâ‚‚â‚“

      Ïƒáµƒáµ¤â‚‚ : Î¼s âŸ¶ Î¼sâ‚‚â‚
      Ïƒáµƒáµ¤â‚‚ = epiHom factor:f

      Ï• : Î¼sâ‚‚ â‰… Î¼sâ‚â‚
      Ï• = splitting factor:f

      lem-0 : Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ â—† âŸ¨ Ï• âŸ©â»Â¹ âˆ¼ Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€
      lem-0 = factors factor:f

      Î“â‚‚ = Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚‚ ]â‡‚á¶œ

      ã‚ : (Î¼sâ‚‚â‚ âŠ” Î¼sâ‚‚â‚“) âŠ” Î¼sâ‚â‚“ â‰… Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“)
      ã‚ = assoc-l-âŠ”-â„’HMTypes

      Ïˆâ»Â¹ : (Î¼sâ‚â‚ âŠ” Î¼sâ‚â‚“) âŸ¶ Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“)
      Ïˆâ»Â¹ = (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† âŸ¨ ã‚ âŸ©

      Î±â‚‚ : â„’HMType âŸ¨ Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“) âŸ©
      Î±â‚‚ = Î±â‚ â‡ƒ[ â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ ]â‡‚


      Î²â‚‚ : â„’HMType âŸ¨ Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“) âŸ©
      Î²â‚‚ = Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚

      module lem-03 where abstract
        Proof : Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (Î¹â‚€ â—† Ïˆâ»Â¹)) âˆ¼ Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€
        Proof = Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (Î¹â‚€ â—† ((âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† âŸ¨ ã‚ âŸ©)))

                  âŸ¨ refl â—ˆ (refl â—ˆ assoc-r-â—† ) âŸ©-âˆ¼

                  Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (Î¹â‚€ â—† (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† âŸ¨ ã‚ âŸ©))

                  âŸ¨ refl â—ˆ (refl â—ˆ (reduce-Î¹â‚€ â—ˆ refl) ) âŸ©-âˆ¼

                  Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (âŸ¨ Ï• âŸ©â»Â¹ â—† Î¹â‚€ â—† âŸ¨ ã‚ âŸ©))

                  âŸ¨ refl â—ˆ (refl â—ˆ (assoc-l-â—†) ) âŸ©-âˆ¼

                  Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (âŸ¨ Ï• âŸ©â»Â¹ â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©)))

                  âŸ¨ refl â—ˆ (assoc-r-â—†) âŸ©-âˆ¼

                  Î¹â‚€ â—† ((Ïƒáµƒâ‚€â‚ â—† âŸ¨ Ï• âŸ©â»Â¹) â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©))

                  âŸ¨ (assoc-r-â—†) âŸ©-âˆ¼

                  (Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† âŸ¨ Ï• âŸ©â»Â¹)) â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©)

                  âŸ¨ (assoc-r-â—†) â—ˆ refl âŸ©-âˆ¼

                  ((Î¹â‚€ â—† Ïƒáµƒâ‚€â‚) â—† âŸ¨ Ï• âŸ©â»Â¹) â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©)

                  âŸ¨ lem-0 â—ˆ refl âŸ©-âˆ¼

                  (Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€) â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©)

                  âŸ¨ assoc-l-â—† âŸ©-âˆ¼

                  Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† (Î¹â‚€ â—† âŸ¨ ã‚ âŸ©))

                  âŸ¨ refl â—ˆ assoc-r-â—† âŸ©-âˆ¼

                  Ïƒáµƒáµ¤â‚‚ â—† ((Î¹â‚€ â—† Î¹â‚€) â—† âŸ¨ ã‚ âŸ©)

                  âŸ¨ refl â—ˆ {!!} âŸ©-âˆ¼

                  Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€

                  âˆ



      module lem-04a where abstract
        Proof : Î“â‚ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚á¶œ â‰¡ Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚‚ ]â‡‚á¶œ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ
        Proof =   Î“â‚ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚á¶œ      âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“â‚} {f = Î¹â‚€} {Ïˆâ»Â¹} âŸ©-â‰¡
                  Î“â‚ â‡ƒ[ Î¹â‚€ â—† Ïˆâ»Â¹ ]â‡‚á¶œ           âŸ¨ cong _â‡ƒ[ Î¹â‚€ â—† Ïˆâ»Â¹ ]â‡‚á¶œ (sym-Path (snd Î“â‚€<Î“â‚)) âŸ©-â‰¡
                  Î“ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïƒáµƒâ‚€â‚ ]â‡‚á¶œ â‡ƒ[ Î¹â‚€ â—† Ïˆâ»Â¹ ]â‡‚á¶œ   âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ} âŸ©-â‰¡
                  Î“ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïƒáµƒâ‚€â‚ â—† (Î¹â‚€ â—† Ïˆâ»Â¹) ]â‡‚á¶œ   âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“} âŸ©-â‰¡
                  Î“ â‡ƒ[ Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† (Î¹â‚€ â—† Ïˆâ»Â¹)) ]â‡‚á¶œ       âŸ¨ Î“ â‡ƒ[â‰€ lem-03.Proof â‰€]â‡‚á¶œ âŸ©-â‰¡
                  Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€ ]â‡‚á¶œ           âŸ¨ sym-Path (functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“}) âŸ©-â‰¡
                  Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚‚ ]â‡‚á¶œ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ      âˆ-â‰¡

      module lem-04b where abstract
        Proof : Î±â‚ â‡ƒ[ Î¹â‚€ â‡ƒâŠ”â‡‚ id ]â‡‚ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‰¡ Î±â‚‚
        Proof = Î±â‚ â‡ƒ[ Î¹â‚€ â‡ƒâŠ”â‡‚ id ]â‡‚ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚

                  âŸ¨ cong _â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ (functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚} {f = (Î¹â‚€ â‡ƒâŠ”â‡‚ id)} {â¦— id , elim-âŠ¥ â¦˜}) âŸ©-â‰¡

                  Î±â‚ â‡ƒ[ (Î¹â‚€ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚

                  âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚} {f = (Î¹â‚€ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜} {g = Ïˆâ»Â¹} âŸ©-â‰¡

                  Î±â‚ â‡ƒ[ (Î¹â‚€ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜ â—† Ïˆâ»Â¹ ]â‡‚

                  âŸ¨ Î±â‚ â‡ƒ[â‰€ lem-04bi â‰€]â‡‚ âŸ©-â‰¡

                  Î±â‚‚

                  âˆ-â‰¡

          where
            lem-04bi : (Î¹â‚€ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜ â—† Ïˆâ»Â¹ âˆ¼ â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜
            lem-04bi = (Î¹â‚€ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜ â—† Ïˆâ»Â¹  âŸ¨ append-â‡ƒâŠ”â‡‚ â—ˆ refl âŸ©-âˆ¼
                        â¦— (Î¹â‚€ â—† id , id â—† elim-âŠ¥) â¦˜ â—† Ïˆâ»Â¹    âŸ¨ cong-âˆ¼ {{isSetoidHom:â¦—â¦˜}} (unit-r-â—† , unit-l-â—†)â—ˆ refl âŸ©-âˆ¼
                        â¦— (Î¹â‚€ , elim-âŠ¥) â¦˜ â—† Ïˆâ»Â¹              âŸ¨ append-â¦—â¦˜ âŸ©-âˆ¼
                        â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â—† Ïˆâ»Â¹ â¦˜          âŸ¨ cong-âˆ¼ {{isSetoidHom:â¦—â¦˜}} (refl , expand-âŠ¥) âŸ©-âˆ¼
                        â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜                âˆ


      module lem-05 where abstract
        Proof : isTypedâ„’HM (Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“) âŠ© (Î“â‚‚ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ) âŠ¢ Î±â‚‚ â‡’ Î²â‚‚) (lam te)
        Proof = {!!}
                -- lam Î±â‚Î“â‚âŠ¢Î²â‚
                -- âŸª Â§-isTypedâ„’HM.prop-2 Ïˆâ»Â¹ âŸ«
                -- >> isTypedâ„’HM ((Î¼sâ‚‚â‚ âŠ” (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“)) âŠ© (Q) , (Î“â‚ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚á¶œ) âŠ¢ _ â‡’ Î²â‚‚) (lam te) <<

                -- âŸª transp-isTypedâ„’HM lem-04a.Proof (Î» i -> lem-04b.Proof i â‡’ Î²â‚‚) âŸ«


      Î“<Î“â‚‚ : Î“ <Î“ Î“â‚‚
      Î“<Î“â‚‚ = record { fst = Ïƒáµƒáµ¤â‚‚ ; snd = refl-â‰¡ }

      -- | Finally we get a typing instance [..] given by [....]

      ğ‘‡ : CtxTypingInstance Î“ (lam te)
      ğ‘‡ = Î¼sâ‚‚â‚ / (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“) âŠ© Î“â‚‚ , Î±â‚‚ â‡’ Î²â‚‚ , Î“<Î“â‚‚ , (lem-05.Proof)

      -- | Now we want to show that this is the initial typing instance.
      -- | > Assume we are given another typing instance.
      module _ (ğ‘† : CtxTypingInstance Î“ (lam te)) where
        open CtxTypingInstance ğ‘† renaming
          ( metas to Î¼sâ‚ƒâ‚
          ; typeMetas to Î¼sâ‚ƒâ‚“
          ; ctx to Î“â‚ƒ
          ; typ to Î´â‚ƒ
          ; isInstance to Î“<Î“â‚ƒ
          ; hasType to Î“â‚ƒâŠ¢Î´â‚ƒ
          )

        -- | We know that the lam typing must have been derived by the
        --   lam rule.
        inR = inv-lam Î“â‚ƒâŠ¢Î´â‚ƒ
        Î±â‚ƒ = inR .fst
        Î²â‚ƒ = inR .snd .fst
        Î±â‚ƒâ‡’Î²â‚ƒ=Î´â‚ƒ = inR .snd .snd .fst
        Î“â‚ƒÎ±â‚ƒâŠ¢Î²â‚ƒ = inR .snd .snd .snd


        -- | The actual proof.
        Ïƒáµƒáµ¤â‚ƒ : Î¼s âŸ¶ Î¼sâ‚ƒâ‚
        Ïƒáµƒáµ¤â‚ƒ = Î“<Î“â‚ƒ .fst

        Î²â‚ƒ' : â„’HMType âŸ¨(Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“ âŠ” âŠ¥)âŸ©
        Î²â‚ƒ' = Î²â‚ƒ â‡ƒ[ Î¹â‚€ ]â‡‚

        Î“â‚ƒ' : â„’HMCtx _ (Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“)
        Î“â‚ƒ' = Î“â‚ƒ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ

        lem-9 : isTypedâ„’HM (Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“ âŠ” âŠ¥ âŠ© (Î±â‚ƒ âˆ· Î“â‚ƒ') â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ âŠ¢ Î²â‚ƒ') te
        lem-9 = Î“â‚ƒÎ±â‚ƒâŠ¢Î²â‚ƒ
                âŸª Â§-isTypedâ„’HM.prop-2 Î¹â‚€ âŸ«

        Î±â‚ƒ' : â„’HMType âŸ¨ Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“ âŸ©
        Î±â‚ƒ' = Î±â‚ƒ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚

        ÏƒÎ±â‚ƒ : st âŸ¶ Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“
        ÏƒÎ±â‚ƒ = â§œsubst (incl Î±â‚ƒ')

        Ïƒáµƒâ‚€â‚ƒ : Î¼sâ‚€ âŸ¶ Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“
        Ïƒáµƒâ‚€â‚ƒ = â¦— Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€ , ÏƒÎ±â‚ƒ â¦˜

        -- | Now some lemma.
        module lem-10a where abstract
          private
            P-0 : Î¹â‚ â—† Î¹â‚€ {b = âŠ¥} â—† (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id) âˆ¼ ÏƒÎ±â‚ƒ â—† Î¹â‚€
            P-0 = Î¹â‚ â—† Î¹â‚€ {b = âŠ¥} â—† (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id)     âŸ¨ assoc-l-â—† âŸ©-âˆ¼
                        Î¹â‚ â—† (Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id))   âŸ¨ refl â—ˆ reduce-Î¹â‚€ âŸ©-âˆ¼
                        Î¹â‚ â—† (Ïƒáµƒâ‚€â‚ƒ â—† Î¹â‚€)            âŸ¨ assoc-r-â—† âŸ©-âˆ¼
                        (Î¹â‚ â—† Ïƒáµƒâ‚€â‚ƒ) â—† Î¹â‚€            âŸ¨ reduce-Î¹â‚ â—ˆ refl âŸ©-âˆ¼
                        (ÏƒÎ±â‚ƒ) â—† Î¹â‚€                   âˆ

          Proof  : Î±â‚€ â‡ƒ[ Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id ]â‡‚ â‰¡ Î±â‚ƒ
          Proof = Î±áµ˜ â‡ƒ[ Î¹â‚ â—† Î¹â‚€ ]â‡‚ â‡ƒ[ Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id ]â‡‚     âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±áµ˜} {f = Î¹â‚ â—† Î¹â‚€} {Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id} âŸ©-â‰¡
                  Î±áµ˜ â‡ƒ[ Î¹â‚ â—† Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚       âŸ¨ Î±áµ˜ â‡ƒ[â‰€ P-0 â‰€]â‡‚ âŸ©-â‰¡
                  Î±áµ˜ â‡ƒ[ ÏƒÎ±â‚ƒ â—† Î¹â‚€ ]â‡‚                       âŸ¨ sym-Path (functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±áµ˜} {f = ÏƒÎ±â‚ƒ} {Î¹â‚€}) âŸ©-â‰¡
                  -- here we need to use the fact that â‡ƒ[ ÏƒÎ±â‚ƒ ]â‡‚, applied to `incl`
                  -- gives us the value of that incl. (since the substitution is abstract)
                  Î±áµ˜ â‡ƒ[ ÏƒÎ±â‚ƒ ]â‡‚ â‡ƒ[ Î¹â‚€ ]â‡‚                   âŸ¨ {!!} âŸ©-â‰¡
                  -- Î±áµ˜ â‡ƒ[ ÏƒÎ±â‚ƒ ]â‡‚ â‡ƒ[ Î¹â‚€ ]â‡‚                   âŸ¨ refl-â‰¡ âŸ©-â‰¡
                  Î±â‚ƒ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ â‡ƒ[ Î¹â‚€ ]â‡‚       âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚ƒ} {f = â¦— id , elim-âŠ¥ â¦˜} {Î¹â‚€} âŸ©-â‰¡
                  Î±â‚ƒ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ â—† Î¹â‚€ ]â‡‚           âŸ¨ Î±â‚ƒ â‡ƒ[â‰€ Â§-Ï–.prop-1  â‰€]â‡‚ âŸ©-â‰¡
                  Î±â‚ƒ â‡ƒ[ id ]â‡‚                             âŸ¨ functoriality-id-â‡ƒ[]â‡‚ âŸ©-â‰¡
                  Î±â‚ƒ                                      âˆ-â‰¡

        -- | And lemma 10b!?
        module lem-10b where abstract
          Proof : Î“â‚€ â‡ƒ[ Ïƒáµƒâ‚€â‚ƒ ]â‡‚á¶œ â‰¡ Î“â‚ƒ'
          Proof = Î“ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ â‡ƒ[ Ïƒáµƒâ‚€â‚ƒ ]â‡‚á¶œ  âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“} âŸ©-â‰¡
                  Î“ â‡ƒ[ Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ƒ ]â‡‚á¶œ       âŸ¨ Î“ â‡ƒ[â‰€ reduce-Î¹â‚€ â‰€]â‡‚á¶œ âŸ©-â‰¡
                  Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€ ]â‡‚á¶œ        âŸ¨ sym-Path (functoriality-â—†-â‡ƒ[]â‡‚á¶œ {Î“ = Î“}) âŸ©-â‰¡
                  Î“ â‡ƒ[ Ïƒáµƒáµ¤â‚ƒ ]â‡‚á¶œ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ   âŸ¨ cong _â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ (snd Î“<Î“â‚ƒ) âŸ©-â‰¡
                  Î“â‚ƒ â‡ƒ[ Î¹â‚€ ]â‡‚á¶œ              âˆ-â‰¡

        Î±â‚€Î“â‚€<Î±â‚ƒÎ“â‚ƒ' : (Î±â‚€ âˆ·' Î“â‚€) <Î“ (Î±â‚ƒ âˆ· Î“â‚ƒ')
        Î±â‚€Î“â‚€<Î±â‚ƒÎ“â‚ƒ' = record { fst = Ïƒáµƒâ‚€â‚ƒ ; snd = Î» i â†’ lem-10a.Proof i âˆ· lem-10b.Proof i }


        ğ‘†-te : CtxTypingInstance (Î±â‚€ âˆ·' Î“â‚€) te
        ğ‘†-te = ((Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“) / âŠ¥ âŠ© Î±â‚ƒ âˆ· Î“â‚ƒ' , Î²â‚ƒ' , Î±â‚€Î“â‚€<Î±â‚ƒÎ“â‚ƒ' , lem-9)

        module Î©R where abstract
          Proof : ğ‘‡-te <TI ğ‘†-te
          Proof = Î© ((Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“) / âŠ¥ âŠ© Î±â‚ƒ âˆ· Î“â‚ƒ' , Î²â‚ƒ' , Î±â‚€Î“â‚€<Î±â‚ƒÎ“â‚ƒ' , lem-9)

        Ïƒáµƒâ‚â‚ƒ : Î¼sâ‚â‚ âŸ¶ Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“
        Ïƒáµƒâ‚â‚ƒ = tiSubâ‚ Î©R.Proof

        ÏƒË£â‚â‚ƒ : Î¼sâ‚â‚“ âŸ¶ (Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“) âŠ” âŠ¥
        ÏƒË£â‚â‚ƒ = tiSubâ‚“ Î©R.Proof

        Ïƒáµƒâ‚‚â‚ƒ : Î¼sâ‚‚â‚ âŸ¶ Î¼sâ‚ƒâ‚
        Ïƒáµƒâ‚‚â‚ƒ = Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ â—† Ï–â‚€
        -- Ïƒâ‚‚â‚ƒ â—† Ï–â‚€

        ÏƒË£â‚‚â‚ƒ : (Î¼sâ‚‚â‚“ âŠ” Î¼sâ‚â‚“) âŸ¶ Î¼sâ‚ƒâ‚ âŠ” Î¼sâ‚ƒâ‚“
        ÏƒË£â‚‚â‚ƒ = â¦— Î¹â‚ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜


        -- | And look at nr 15, how great!
        module lem-15 where abstract
          Proof : Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ©) âˆ¼ Î¹â‚€ â—† Ïƒáµƒâ‚€â‚
          Proof = Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ©)             âŸ¨ assoc-r-â—† âŸ©-âˆ¼
                  (Ïƒáµƒáµ¤â‚‚ â—† Î¹â‚€) â—† âŸ¨ Ï• âŸ©             âŸ¨ {!!} âŸ©-âˆ¼
                  --  lem-0 â—ˆ refl âŸ©-âˆ¼
                  Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ â—† âŸ¨ Ï• âŸ©â»Â¹ â—† âŸ¨ Ï• âŸ©     âŸ¨ assoc-l-â—† âŸ©-âˆ¼
                  Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ â—† (âŸ¨ Ï• âŸ©â»Â¹ â—† âŸ¨ Ï• âŸ©)   âŸ¨ refl â—ˆ inv-l-â—† (of Ï•) âŸ©-âˆ¼
                  Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ â—† id                 âŸ¨ unit-r-â—† âŸ©-âˆ¼
                  Î¹â‚€ â—† Ïƒáµƒâ‚€â‚                      âˆ

        module lem-16 where abstract
          Proof : Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ) âˆ¼ Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€
          Proof = Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ)     âŸ¨ assoc-r-â—† âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ©) â—† Ïƒáµƒâ‚â‚ƒ     âŸ¨ lem-15.Proof â—ˆ refl âŸ©-âˆ¼
                  Î¹â‚€ â—† Ïƒáµƒâ‚€â‚ â—† Ïƒáµƒâ‚â‚ƒ               âŸ¨ assoc-l-â—† âŸ©-âˆ¼
                  Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ â—† Ïƒáµƒâ‚â‚ƒ)             âŸ¨ refl â—ˆ subProof Î©R.Proof âŸ©-âˆ¼
                  Î¹â‚€ â—† (Ïƒáµƒâ‚€â‚ƒ)                   âŸ¨ reduce-Î¹â‚€ âŸ©-âˆ¼
                  (Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€)                    âˆ

        module lem-20 where abstract
          Proof : Ïƒáµƒáµ¤â‚‚ â—† Ïƒáµƒâ‚‚â‚ƒ âˆ¼ Ïƒáµƒáµ¤â‚ƒ
          Proof = Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ â—† Ï–â‚€)  âŸ¨ assoc-r-â—† âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ) â—† Ï–â‚€  âŸ¨ lem-16.Proof â—ˆ refl âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€ â—† Ï–â‚€                   âŸ¨ assoc-l-â—† âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚ƒ â—† (Î¹â‚€ â—† Ï–â‚€)                 âŸ¨ refl â—ˆ reduce-Î¹â‚€ âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚ƒ â—† id                        âŸ¨ unit-r-â—† âŸ©-âˆ¼
                  Ïƒáµƒáµ¤â‚ƒ                             âˆ

        -- | Also here, super, right?
        module lem-30 where abstract
          Proof : Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ âˆ¼ Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ
          Proof = cancel-epi {{_}} {{isEpi:epiHom factor:f}} lem-30a
            where
              lem-30a : Ïƒáµƒáµ¤â‚‚ â—† (Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€) âˆ¼ Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ)
              lem-30a = Ïƒáµƒáµ¤â‚‚ â—† (Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€)           âŸ¨ assoc-r-â—† âŸ©-âˆ¼
                        (Ïƒáµƒáµ¤â‚‚ â—† Ïƒáµƒâ‚‚â‚ƒ) â—† Î¹â‚€           âŸ¨ lem-20.Proof â—ˆ refl âŸ©-âˆ¼
                        Ïƒáµƒáµ¤â‚ƒ â—† Î¹â‚€                    âŸ¨ lem-16.Proof â»Â¹ âŸ©-âˆ¼
                        Ïƒáµƒáµ¤â‚‚ â—† (Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ)   âˆ


        -------------------------------------------------
        -- these lemmas are needed for the Î±â‚‚ â‡ƒ[ "Ïƒâ‚‚â‚ƒ" ]â‡‚ â‰¡ Î±â‚ƒ proof
        module lem-31 where abstract
          Proof : â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ âˆ¼ âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜
          Proof = â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , â¦— Î¹â‚ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜ â¦˜

                  âŸ¨ cong-âˆ¼ {{isSetoidHom:â¦—â¦˜}} (lem-30.Proof , refl) âŸ©-âˆ¼

                  â¦— Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , â¦— Î¹â‚ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜ â¦˜

                  âŸ¨ {!!} âŸ©-âˆ¼

                  âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— â¦— Î¹â‚€ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , Î¹â‚ â—† âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ â¦˜ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜

                  âŸ¨ refl â—ˆ â¦—â‰€ â¦—â‰€ assoc-l-â—† , assoc-l-â—† â‰€â¦˜ , refl â‰€â¦˜ âŸ©-âˆ¼

                  âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— â¦— Î¹â‚€ â—† (âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ) , Î¹â‚ â—† (âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ) â¦˜ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜

                  âŸ¨ refl â—ˆ â¦—â‰€ expand-Î¹â‚€,Î¹â‚ â»Â¹ , refl â‰€â¦˜ âŸ©-âˆ¼

                  âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜

                  âˆ

        -- | And nr 32, that is almost 42.
        module lem-32 where abstract
          Proof : Ïˆâ»Â¹ â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜) âˆ¼ â¦— Ïƒáµƒâ‚â‚ƒ , (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â¦˜
          Proof = (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† âŸ¨ ã‚ âŸ© â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† _)

                  âŸ¨ assoc-r-â—† âŸ©-âˆ¼

                  (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† âŸ¨ ã‚ âŸ© â—† âŸ¨ ã‚ âŸ©â»Â¹ â—† _

                  âŸ¨ assoc-l-â—† â—ˆ refl âŸ©-âˆ¼

                  (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† (âŸ¨ ã‚ âŸ© â—† âŸ¨ ã‚ âŸ©â»Â¹) â—† _

                  âŸ¨ refl â—ˆ (inv-r-â—† (of ã‚)) â—ˆ refl âŸ©-âˆ¼

                  (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† id â—† _

                  âŸ¨ unit-r-â—† â—ˆ refl âŸ©-âˆ¼

                  (âŸ¨ Ï• âŸ©â»Â¹ â‡ƒâŠ”â‡‚ id) â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜

                  âŸ¨ append-â‡ƒâŠ”â‡‚ âŸ©-âˆ¼

                  â¦— âŸ¨ Ï• âŸ©â»Â¹ â—† (âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ) , id â—† (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â¦˜

                  âŸ¨ â¦—â‰€ assoc-r-â—† âˆ™ (inv-l-â—† (of Ï•) â—ˆ refl) âˆ™ unit-l-â—† , unit-l-â—† â‰€â¦˜ âŸ©-âˆ¼

                  â¦— Ïƒáµƒâ‚â‚ƒ , (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â¦˜

                  âˆ

        module lem-33 where abstract
          Proof : Î¹â‚€ â—† â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜) âˆ¼ Ïƒáµƒâ‚â‚ƒ
          Proof = Î¹â‚€ â—† â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† _

                  âŸ¨ reduce-Î¹â‚€ â—ˆ refl âŸ©-âˆ¼

                  Î¹â‚€ â—† Ïˆâ»Â¹ â—† _

                  âŸ¨ assoc-l-â—† âŸ©-âˆ¼

                  Î¹â‚€ â—† (Ïˆâ»Â¹ â—† _)

                  âŸ¨ refl â—ˆ lem-32.Proof âŸ©-âˆ¼

                  Î¹â‚€ â—† â¦— Ïƒáµƒâ‚â‚ƒ , (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â¦˜

                  âŸ¨ reduce-Î¹â‚€ âŸ©-âˆ¼

                  Ïƒáµƒâ‚â‚ƒ

                  âˆ

        module lem-34 where abstract
          Proof : â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜) âˆ¼ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜
          Proof = Â§-Ï–.prop-2 lem-34a
            where
              lem-34a : Î¹â‚€ â—† (â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜)) âˆ¼ Î¹â‚€ â—† ((Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜)
              lem-34a = Î¹â‚€ â—† (â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜))

                        âŸ¨ refl â—ˆ (refl â—ˆ lem-31.Proof ) âŸ©-âˆ¼

                        Î¹â‚€ â—† (â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜))

                        âŸ¨ assoc-r-â—† âŸ©-âˆ¼

                        (Î¹â‚€ â—† â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜) â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜)

                        âŸ¨ lem-33.Proof âŸ©-âˆ¼

                        Ïƒáµƒâ‚â‚ƒ

                        âŸ¨ unit-r-â—† â»Â¹ âŸ©-âˆ¼

                        Ïƒáµƒâ‚â‚ƒ â—† id

                        âŸ¨ refl â—ˆ reduce-Î¹â‚€ â»Â¹ âŸ©-âˆ¼

                        Ïƒáµƒâ‚â‚ƒ â—† (Î¹â‚€  â—† â¦— id , elim-âŠ¥ â¦˜)

                        âŸ¨ assoc-r-â—† âŸ©-âˆ¼

                        (Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ ) â—† â¦— id , elim-âŠ¥ â¦˜

                        âŸ¨ reduce-Î¹â‚€ â»Â¹ â—ˆ refl âŸ©-âˆ¼

                        (Î¹â‚€ â—† (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id)) â—† â¦— id , elim-âŠ¥ â¦˜

                        âŸ¨ assoc-l-â—† âŸ©-âˆ¼

                        Î¹â‚€ â—† ((Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜)

                        âˆ


        -- | Maybe this one's great as well.
        module lem-35 where abstract
          Proof : Î±â‚ â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚ â‰¡ Î±â‚€ â‡ƒ[ Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id ]â‡‚
          Proof = Î±â‚ â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚                         âŸ¨ sym-Path (cong _â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚ (Î» i -> split-Listá´°Â² (Î±â‚€Î“â‚€<Î±â‚Î“â‚ .snd i) .fst)) âŸ©-â‰¡
                  Î±â‚€ â‡ƒ[ (Ïƒáµƒâ‚€â‚ â‡ƒâŠ”â‡‚ id) ]â‡‚ â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚     âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚€} {f = (Ïƒáµƒâ‚€â‚ â‡ƒâŠ”â‡‚ id)} {(Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id)} âŸ©-â‰¡
                  Î±â‚€ â‡ƒ[ (Ïƒáµƒâ‚€â‚ â‡ƒâŠ”â‡‚ id) â—† (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚         âŸ¨ Î±â‚€ â‡ƒ[â‰€ functoriality-â—†-âŠ” â»Â¹ â‰€]â‡‚ âŸ©-â‰¡
                  Î±â‚€ â‡ƒ[ ((Ïƒáµƒâ‚€â‚ â—† Ïƒáµƒâ‚â‚ƒ) â‡ƒâŠ”â‡‚ (id â—† id)) ]â‡‚             âŸ¨ Î±â‚€ â‡ƒ[â‰€ subProof Î©R.Proof â‰€â‡ƒâŠ”â‡‚â‰€ unit-2-â—† â‰€]â‡‚ âŸ©-â‰¡
                  Î±â‚€ â‡ƒ[ (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚                        âˆ-â‰¡

        module lem-40 where abstract
          Proof : Î±â‚‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚ â‰¡ Î±â‚ƒ'
          Proof = Î±â‚ â‡ƒ[ â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ ]â‡‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚

                  âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚} {f = â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜} {â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜} âŸ©-â‰¡

                  Î±â‚ â‡ƒ[ â¦— Î¹â‚€ â—† Ïˆâ»Â¹ , elim-âŠ¥ â¦˜ â—† â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚

                  âŸ¨ Î±â‚ â‡ƒ[â‰€ lem-34.Proof â‰€]â‡‚ âŸ©-â‰¡

                  Î±â‚ â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) â—† â¦— id , elim-âŠ¥ â¦˜ ]â‡‚

                  âŸ¨ sym-Path (functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î±â‚} {f = (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id)} {â¦— id , elim-âŠ¥ â¦˜}) âŸ©-â‰¡

                  Î±â‚ â‡ƒ[ (Ïƒáµƒâ‚â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚

                  âŸ¨ cong _â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ lem-35.Proof âŸ©-â‰¡

                  Î±â‚€ â‡ƒ[ (Ïƒáµƒâ‚€â‚ƒ â‡ƒâŠ”â‡‚ id) ]â‡‚ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚

                  âŸ¨ cong _â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚ (Î» i -> split-Listá´°Â² (Î±â‚€Î“â‚€<Î±â‚ƒÎ“â‚ƒ' .snd i) .fst) âŸ©-â‰¡

                  Î±â‚ƒ â‡ƒ[ â¦— id , elim-âŠ¥ â¦˜ ]â‡‚

                  âŸ¨ refl-â‰¡ âŸ©-â‰¡

                  Î±â‚ƒ'

                  âˆ-â‰¡


        -------------------------------------------------------
        -- now the lemmas for Î²â‚‚ â‡ƒ[ "Ïƒâ‚‚â‚ƒ" ]â‡‚ â‰¡ Î²â‚ƒ proof

        -- | Well look here, we are almost done.
        module lem-41 where abstract
          Proof : Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€ ]â‡‚ â‰¡ Î²â‚ƒ'
          Proof = Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€ ]â‡‚

                  âŸ¨ (functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î²â‚} {f = Ïˆâ»Â¹} {â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€}) âŸ©-â‰¡

                  Î²â‚ â‡ƒ[ Ïˆâ»Â¹ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€) ]â‡‚

                  âŸ¨ Î²â‚ â‡ƒ[â‰€ lem-41a â‰€]â‡‚ âŸ©-â‰¡

                  Î²â‚ â‡ƒ[ â¦— Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚â‚ƒ â¦˜ ]â‡‚

                  âŸ¨ typProof Î©R.Proof âŸ©-â‰¡

                  Î²â‚ƒ'

                  âˆ-â‰¡

            where
              lem-41a : Ïˆâ»Â¹ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€) âˆ¼ â¦— Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚â‚ƒ â¦˜
              lem-41a = Ïˆâ»Â¹ â—† (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€)

                    âŸ¨ assoc-r-â—† âŸ©-âˆ¼

                    (Ïˆâ»Â¹ â—† â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜) â—† Î¹â‚€

                    âŸ¨ (refl â—ˆ lem-31.Proof) â—ˆ refl âŸ©-âˆ¼

                    Ïˆâ»Â¹ â—† (âŸ¨ ã‚ âŸ©â»Â¹ â—† â¦— âŸ¨ Ï• âŸ© â—† Ïƒáµƒâ‚â‚ƒ , ÏƒË£â‚â‚ƒ â—† Ï–â‚€ â¦˜) â—† Î¹â‚€

                    âŸ¨ lem-32.Proof â—ˆ refl âŸ©-âˆ¼

                    â¦— Ïƒáµƒâ‚â‚ƒ , (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â¦˜ â—† Î¹â‚€

                    âŸ¨ append-â¦—â¦˜ âŸ©-âˆ¼

                    â¦— Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ , (ÏƒË£â‚â‚ƒ â—† Ï–â‚€) â—† Î¹â‚€ â¦˜

                    âŸ¨ â¦—â‰€ refl , assoc-l-â—† â‰€â¦˜ âŸ©-âˆ¼

                    â¦— Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚â‚ƒ â—† (Ï–â‚€ â—† Î¹â‚€) â¦˜

                    âŸ¨ â¦—â‰€ refl , ((refl â—ˆ Â§-Ï–.prop-1) âˆ™ unit-r-â—†) â‰€â¦˜ âŸ©-âˆ¼

                    â¦— Ïƒáµƒâ‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚â‚ƒ â¦˜

                    âˆ

        -- | And wow, we did reach 42.
        module lem-42 where abstract
          Proof : Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚ â‰¡ Î²â‚ƒ
          Proof = Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚

                  âŸ¨ Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[â‰€ unit-r-â—† â»Â¹ âˆ™ (refl â—ˆ reduce-Î¹â‚€ â»Â¹) âˆ™ assoc-r-â—† â‰€]â‡‚ âŸ©-â‰¡

                  Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€) â—† Ï–â‚€ ]â‡‚

                  âŸ¨ sym-Path (functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚} {f = (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€)} {Ï–â‚€}) âŸ©-â‰¡

                  Î²â‚ â‡ƒ[ Ïˆâ»Â¹ ]â‡‚ â‡ƒ[ (â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ â—† Î¹â‚€) ]â‡‚ â‡ƒ[ Ï–â‚€ ]â‡‚

                  âŸ¨ cong _â‡ƒ[ Ï–â‚€ ]â‡‚ lem-41.Proof âŸ©-â‰¡

                  Î²â‚ƒ â‡ƒ[ Î¹â‚€ ]â‡‚ â‡ƒ[ Ï–â‚€ ]â‡‚

                  âŸ¨ functoriality-â—†-â‡ƒ[]â‡‚ {Ï„ = Î²â‚ƒ} {f = Î¹â‚€} {Ï–â‚€} âŸ©-â‰¡

                  Î²â‚ƒ â‡ƒ[ Î¹â‚€ â—† Ï–â‚€ ]â‡‚

                  âŸ¨ Î²â‚ƒ â‡ƒ[â‰€ reduce-Î¹â‚€ â‰€]â‡‚ âŸ©-â‰¡

                  Î²â‚ƒ â‡ƒ[ id ]â‡‚

                  âŸ¨ functoriality-id-â‡ƒ[]â‡‚ âŸ©-â‰¡

                  Î²â‚ƒ

                  âˆ-â‰¡


        -- | Which means that here is our result!
        -- here we additionally need that â‡’ distributes over substitution (or the other way round)
        lem-50 : (Î±â‚‚ â‡’ Î²â‚‚) â‡ƒ[ â¦— Ïƒáµƒâ‚‚â‚ƒ â—† Î¹â‚€ , ÏƒË£â‚‚â‚ƒ â¦˜ ]â‡‚ â‰¡ Î±â‚ƒ' â‡’ Î²â‚ƒ
        lem-50 = {!!}
        -- Î» i -> lem-40 i â‡’ lem-42 i

        -- | But what exactly is your problem then ?

        isInitial:ğ‘‡ : ğ‘‡ <TI ğ‘†
        isInitial:ğ‘‡ = record { tiSubâ‚ = Ïƒáµƒâ‚‚â‚ƒ ; tiSubâ‚“ = ÏƒË£â‚‚â‚ƒ ; typProof = trans-Path lem-50 Î±â‚ƒâ‡’Î²â‚ƒ=Î´â‚ƒ ; subProof = lem-20.Proof }

      Result : InitialCtxTypingInstance Î“ (lam te)
      Result = ğ‘‡ , isInitial:ğ‘‡

-- //




